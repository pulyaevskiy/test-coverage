// Copyright (c) 2018, Anatoly Pulyaevskiy. All rights reserved. Use of this source code
// is governed by a BSD-style license that can be found in the LICENSE file.

import 'dart:async';
import 'dart:convert';
import 'dart:io';

import 'package:coverage/coverage.dart' as coverage;
import 'package:glob/glob.dart';
import 'package:lcov/lcov.dart';
import 'package:path/path.dart' as path;

/// Logs a line, with a prefix to distinguish from test outputs.
void logLine(String line, {String prefix}) {
  prefix ??= '>>> ';

  var lines = line.split(RegExp(r'[\r\n]', multiLine: false));
  for (var l in lines) {
    print('$prefix$l');
  }
}

void logBreakLine() {
  logLine(
      '-----------------------------------------------------------------------------',
      prefix: '');
}

final _sep = path.separator;

/// Finds the test files in the [packageRoot]
List<File> findTestFiles(Directory packageRoot, {Glob excludeGlob}) {
  final testsPath = path.join(packageRoot.absolute.path, 'test');
  final testsRoot = Directory(testsPath);
  final contents = testsRoot.listSync(recursive: true);
  final result = <File>[];
  for (final item in contents) {
    if (item is! File) continue;
    if (!item.path.endsWith('_test.dart')) continue;
    final relativePath = item.path.substring(packageRoot.path.length + 1);
    if (excludeGlob != null && excludeGlob.matches(relativePath)) {
      continue;
    }
    result.add(item);
  }
  return result;
}

class TestFileInfo {
  final File testFile;
  final String alias;
  final String import;

  TestFileInfo._(this.testFile, this.alias, this.import);

  factory TestFileInfo.forFile(File testFile) {
    final parts = testFile.absolute.path.split(_sep).toList();
    var relative = <String>[];
    while (parts.last != 'test') {
      relative.add(parts.last);
      parts.removeLast();
    }
    relative = relative.reversed.toList();
    final alias = relative.join('_').replaceFirst('.dart', '');
    final importPath = relative.join('/');
    final import = "import '$importPath' as $alias;";
    return TestFileInfo._(testFile, alias, import);
  }
}

/// Generates `.test_coverage.dart`, that calls [testFiles] `main` functions.
void generateMainScript(Directory packageRoot, List<File> testFiles,
    {String forceCollect}) {
  final imports = <String>[];
  final mainBody = <String>[];

  var useLineMark = forceCollect != null && forceCollect.trim().isNotEmpty;

  for (final test in testFiles) {
    final info = TestFileInfo.forFile(test);
    imports.add(info.import);
    mainBody.add('  ${info.alias}.main();');
  }
  imports.sort();

  final buffer = StringBuffer()
    ..writeln('// Auto-generated by test_coverage. Do not edit by hand.')
    ..writeln('// Consider adding this file to your .gitignore.')
    ..writeln();

  if (useLineMark) {
    buffer..writeln("import 'package:test/test.dart';")..writeln();
  }

  imports.forEach(buffer.writeln);
  buffer..writeln()..writeln('void main() {');
  mainBody.forEach(buffer.writeln);

  if (useLineMark) {
    buffer.writeln('''
  
  test('test_coverage finished!', () {
    print('\\n$forceCollect\\n');
  } );
  ''');
  }

  buffer.writeln('}');

  File(
    path.join(packageRoot.path, 'test', '.test_coverage.dart'),
  ).writeAsStringSync(buffer.toString());
}

/// Runs the tests at generated `.test_coverage.dart` and collects coverage.
Future<void> runTestsAndCollect(
  String packageRoot,
  String port, {
  bool printOutput = false,
  Duration timeout,
  String forceCollect,
  bool forceExitAfterCollect = false,
}) async {
  final script = path.join(packageRoot, 'test', '.test_coverage.dart');
  final dartArgs = <String>[
    '--pause-isolates-on-exit',
    '--enable_asserts',
    '--enable-vm-service=$port',
    script
  ];

  var useLineMark = forceCollect != null && forceCollect.trim().isNotEmpty;

  logBreakLine();
  logLine('PARAMETERS:\n'
      '  packageRoot: $packageRoot\n'
      '  --port: $port (vm-service)\n'
      '  --print-test-output: $printOutput\n'
      '  --timeout: ${timeout != null ? '${timeout.inSeconds}s' : 'no'}\n'
      '  --force-collect: ${forceCollect != null ? 'true\n    --line-mark: $forceCollect' : 'false'}\n'
      '  --force-exit-after-collect: $forceExitAfterCollect\n'
      'Running Test Coverage...');
  logBreakLine();

  final process = await Process.start('dart', dartArgs,
      workingDirectory: packageRoot, runInShell: true);

  final processCompleted = Completer<bool>();

  if (timeout != null) {
    Future.delayed(timeout, () async {
      if (!processCompleted.isCompleted) {
        logLine('Process timeout! Killing it...');
        await _processKill(process, dartArgs);
        processCompleted.complete(false);
      }
    });
  }

  final serviceUriCompleter = Completer<Uri>();
  final testCoverageFinishedCompleter = Completer<bool>();

  process.stdout
      .transform(utf8.decoder)
      .transform(const LineSplitter())
      .listen((line) {
    if (useLineMark &&
        line.contains(forceCollect) &&
        !testCoverageFinishedCompleter.isCompleted) {
      testCoverageFinishedCompleter.complete(true);
    }
    if (printOutput) print(line);
    if (serviceUriCompleter.isCompleted) return;
    final uri = _extractObservatoryUri(line);
    if (uri != null) {
      serviceUriCompleter.complete(uri);
    } else {
      serviceUriCompleter.completeError(line);
    }
  });

  final serviceUri = await serviceUriCompleter.future.catchError((error) {
    _processKill(process, dartArgs);
  });

  if (serviceUri == null) {
    throw StateError('Could not run tests with Observatory enabled. '
        'Try setting a different port with --port option.');
  }

  var waitPaused = true;

  if (useLineMark) {
    final testCoverageFinished = await testCoverageFinishedCompleter.future;
    if (!testCoverageFinished) {
      throw StateError("Can't find line mark: $forceCollect");
    }
    waitPaused = false;
  }

  Map<String, Map<int, int>> hitMap;
  try {
    logLine('Collecting coverage...');
    final data = await coverage.collect(
        serviceUri, waitPaused, waitPaused, false, {},
        timeout: timeout);
    hitMap = await coverage.createHitmap(data['coverage']);
  } catch (e) {
    logLine('Error while collection coverage!');
    rethrow;
  } finally {
    if (forceExitAfterCollect) {
      logLine('Killing Tests Process...');
      await _processKill(process, dartArgs);
      processCompleted.complete(false);
    }
    if (!useLineMark) {
      logLine('Waiting process to exit...');
      await process.stderr.drain<List<int>>();
    }
  }

  logLine('Waiting Tests process to exit...');
  final exitStatus = await process.exitCode;

  logBreakLine();

  if (!processCompleted.isCompleted) {
    processCompleted.complete(true);
  }

  var processCompletedOK = await processCompleted.future;

  logLine('processCompletedOK: $processCompletedOK');

  await _processKill(process, dartArgs);

  if ((processCompletedOK && exitStatus != 0) ||
      (!processCompletedOK && exitStatus != -9)) {
    throw 'Tests failed with exit code $exitStatus';
  }

  final resolver = coverage.Resolver(
    packagesPath: path.join(packageRoot, '.packages'),
  );
  final lcov = coverage.LcovFormatter(
    resolver,
    reportOn: ['lib${path.separator}'],
    basePath: packageRoot,
  );
  final coverageData = await lcov.format(hitMap);
  final coveragePath = path.join(packageRoot, 'coverage');
  final coverageDir = Directory(coveragePath);
  if (!coverageDir.existsSync()) {
    coverageDir.createSync();
  }
  File(path.join(coveragePath, 'lcov.info')).writeAsStringSync(coverageData);
}

/// Kills a [process] checking for childs to kill.
void _processKill(Process process, List<String> cmdArgs) async {
  var pid = process.pid;

  var runningFromBash = await _isProcessRunningFromBash(process, cmdArgs);

  // Flutter SDK may use a bash/sh script to execute Dart/Flutter binary,
  // demanding to also kill the child processes,
  // and not only the main bash/sh process.
  if (runningFromBash) {
    logLine(
        'Detected Dart/Flutter process running from bash/sh! Looking for bash/sh child PIDs...');

    var psBin = await getPsBinaryPath();
    var psResult = await Process.run(psBin, []);
    var psOutput = psResult.stdout as String;

    var psLines = psOutput.split(RegExp(r'[\r\n]+')).where((l) {
      var matchProcess = cmdArgs.where((e) => !l.contains(e)).isEmpty;
      return matchProcess;
    }).toList();

    var allPIDs = psLines
        .map((e) => e.trim().split(RegExp(r'\s+'))[0])
        .map((e) => int.tryParse(e))
        .where((e) => e != null)
        .where((e) => e != pid)
        .toList();

    if (allPIDs.isNotEmpty) {
      logLine('Killing child PIDs: $allPIDs');
      allPIDs.forEach((pid) => Process.killPid(pid, ProcessSignal.sigkill));
    }
  }

  logLine(
      'Killing Process [pid: ${process.pid}]: ${process.kill(ProcessSignal.sigkill)}');
}

/// Checks if the tests process is running from a bash script.
/// If [process] PID is from bash/sh and not the actual Dart/Flutter binary.
Future<bool> _isProcessRunningFromBash(
    Process process, List<String> cmdArgs) async {
  var psBin = await getPsBinaryPath();
  if (psBin == null) return false;

  var pid = process.pid;

  var psResult = await Process.run(psBin, ['-p', '$pid']);
  var psOutput = psResult.stdout as String;
  var psLine = psOutput
      .split(RegExp(r'[\r\n]+'))
      .firstWhere((l) => l.contains('$pid'), orElse: () => '');
  var psLineParts = psLine.split(RegExp(r'\s+'));

  var idx = psLineParts.indexOf(cmdArgs[0]);

  var runningFromBash = false;
  if (idx > 2) {
    var bashBin = psLineParts[idx - 2];
    runningFromBash = bashBin.contains('bash') || bashBin.contains('sh');
  }

  return runningFromBash;
}

String _psBinaryPath;

/// Returns binary path of `ps` command, or null if not found.
Future<String> getPsBinaryPath() async {
  _psBinaryPath ??= (await findCommandPath('ps')) ?? '';
  return _psBinaryPath.isNotEmpty ? _psBinaryPath : null;
}

String _genHTMLBinaryPath;

/// Returns binary path of `genhtml` command, or null if not found.
Future<String> getGenHTMLBinaryPath() async {
  _genHTMLBinaryPath ??= (await findCommandPath('genhtml')) ?? '';
  return _genHTMLBinaryPath.isNotEmpty ? _genHTMLBinaryPath : null;
}

/// Uses command `which` to resolve the binary path of [command].
Future<String> findCommandPath(String command) async {
  var result = await Process.run('which', [command]);
  if (result.exitCode != 0) return null;
  var bin = result.stdout.toString().trim();
  return bin.isNotEmpty ? bin : null;
}

// copied from `coverage` package
Uri _extractObservatoryUri(String str) {
  const kObservatoryListening = 'Observatory listening on ';
  final msgPos = str.indexOf(kObservatoryListening);
  if (msgPos == -1) return null;
  final startPos = msgPos + kObservatoryListening.length;
  final endPos = str.indexOf(RegExp(r'(\s|$)'), startPos);
  try {
    return Uri.parse(str.substring(startPos, endPos));
  } on FormatException {
    return null;
  }
}

double calculateLineCoverage(File lcovReport) {
  final report = Report.fromCoverage(lcovReport.readAsStringSync());
  var totalLines = 0;
  var hitLines = 0;
  for (final rec in report.records) {
    for (final line in rec.lines.data) {
      totalLines++;
      hitLines += (line.executionCount > 0) ? 1 : 0;
    }
  }
  return hitLines / totalLines;
}

void generateBadge(Directory packageRoot, double lineCoverage) {
  const leftWidth = 59;
  final value = '${(lineCoverage * 100).floor()}%';
  final color = _color(lineCoverage);
  final metrics = _BadgeMetrics.forPercentage(lineCoverage);
  final rightWidth = metrics.width - leftWidth;
  final content = _kBadgeTemplate
      .replaceAll('{width}', metrics.width.toString())
      .replaceAll('{rightWidth}', rightWidth.toString())
      .replaceAll('{rightX}', metrics.rightX.toString())
      .replaceAll('{rightLength}', metrics.rightLength.toString())
      .replaceAll('{color}', color.toString())
      .replaceAll('{value}', value.toString());
  File(path.join(packageRoot.path, 'coverage_badge.svg'))
      .writeAsStringSync(content);
}

class _BadgeMetrics {
  final int width;
  final int rightX;
  final int rightLength;

  _BadgeMetrics({this.width, this.rightX, this.rightLength});

  factory _BadgeMetrics.forPercentage(double value) {
    final pct = (value * 100).floor();
    if (pct.toString().length == 1) {
      return _BadgeMetrics(
        width: 88,
        rightX: 725,
        rightLength: 190,
      );
    } else if (pct.toString().length == 2) {
      return _BadgeMetrics(
        width: 94,
        rightX: 755,
        rightLength: 250,
      );
    } else {
      return _BadgeMetrics(
        width: 102,
        rightX: 795,
        rightLength: 330,
      );
    }
  }
}

String _color(double percentage) {
  final map = {
    0.0: _Color(0xE0, 0x5D, 0x44),
    0.5: _Color(0xE0, 0x5D, 0x44),
    0.6: _Color(0xDF, 0xB3, 0x17),
    0.9: _Color(0x97, 0xCA, 0x00),
    1.0: _Color(0x44, 0xCC, 0x11),
  };
  double lower;
  double upper;
  for (final key in map.keys) {
    if (percentage < key) {
      upper = key;
      break;
    }
    if (key < 1.0) lower = key;
  }
  upper ??= 1.0;
  final lowerColor = map[lower];
  final upperColor = map[upper];
  final range = upper - lower;
  final rangePct = (percentage - lower) / range;
  final pctLower = 1 - rangePct;
  final pctUpper = rangePct;
  final r = (lowerColor.r * pctLower + upperColor.r * pctUpper).floor();
  final g = (lowerColor.g * pctLower + upperColor.g * pctUpper).floor();
  final b = (lowerColor.b * pctLower + upperColor.b * pctUpper).floor();
  final color = _Color(r, g, b);
  return color.toString();
}

class _Color {
  final int r, g, b;

  _Color(this.r, this.g, this.b);

  @override
  String toString() =>
      '#${((1 << 24) + (r << 16) + (g << 8) + b).toRadixString(16).substring(1)}';
}

const _kBadgeTemplate = '''
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="{width}" height="20">
  <linearGradient id="b" x2="0" y2="100%">
    <stop offset="0" stop-color="#bbb" stop-opacity=".1"/>
    <stop offset="1" stop-opacity=".1"/>
  </linearGradient>
  <clipPath id="a">
    <rect width="{width}" height="20" rx="3" fill="#fff"/>
  </clipPath>
  <g clip-path="url(#a)">
    <path fill="#555" d="M0 0h59v20H0z"/>
    <path fill="{color}" d="M59 0h{rightWidth}v20H59z"/>
    <path fill="url(#b)" d="M0 0h{width}v20H0z"/>
  </g>
  <g fill="#fff" text-anchor="middle" font-family="DejaVu Sans,Verdana,Geneva,sans-serif" font-size="110">
    <text x="305" y="150" fill="#010101" fill-opacity=".3" transform="scale(.1)" textLength="490">coverage</text>
    <text x="305" y="140" transform="scale(.1)" textLength="490">coverage</text>
    <text x="{rightX}" y="150" fill="#010101" fill-opacity=".3" transform="scale(.1)" textLength="{rightLength}">{value}</text>
    <text x="{rightX}" y="140" transform="scale(.1)" textLength="{rightLength}">{value}</text>
  </g>
</svg>
''';
